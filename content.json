{"meta":{"title":"daraqiao.blog","subtitle":null,"description":"哆啦巧的博客","author":"doraqiao","url":"http://doraqiao.top"},"pages":[{"title":"关于哆啦巧","date":"2018-11-13T02:25:10.067Z","updated":"2018-11-13T02:25:10.065Z","comments":true,"path":"about/index.html","permalink":"http://doraqiao.top/about/index.html","excerpt":"","text":"个人信息 哆啦巧 / 22岁 / 女 Web前端工程师 / 技术渣渣 / 技术小白一枚 邮箱：hxq.951@163.com 目前工作地点：广州 项目经验 围住猫熊-小程序游戏类目（未上线，仅作为学习之用） 本人的毕设作品，使用白鹭引擎+h5的canvas，算法为贪心算法+最短路径算法 游戏模拟《围住神经猫》进行开发，猫熊没有被玩家所设的障碍物围困则为胜利，否则失败 立flag： 学习ES6！！点击此去阮大大es6教程 学习使用webpack、Gulp等开发工具"},{"title":"更新日志","date":"2019-01-14T08:33:28.933Z","updated":"2019-01-14T08:33:28.886Z","comments":true,"path":"board/index.html","permalink":"http://doraqiao.top/board/index.html","excerpt":"","text":"2019-01-142018年度总结 发布 2018-12-29封装axios和统一管理api接口 发布 2018-12-19LeetCode题目之础计算法-数学 发布 2018-11-14leetCode题目之初级算法-字符串 发布 2018-11-12leetCode题目之初级算法-数组 发布 2018.10.29使用VUE开发项目时所遇到的问题 发布 2018.10.12 整理好更新日志和关于我《学习用hexo搭建博客》 发布"}],"posts":[{"title":"'2018年度总结'","slug":"2018年度总结","date":"2019-01-03T04:16:16.000Z","updated":"2019-01-03T04:16:16.648Z","comments":true,"path":"2019/01/03/2018年度总结/","link":"","permalink":"http://doraqiao.top/2019/01/03/2018年度总结/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"封装axios和统一管理api接口","slug":"封装axios和统一管理api接口","date":"2018-12-29T11:00:00.000Z","updated":"2019-01-03T04:10:44.400Z","comments":true,"path":"2018/12/29/封装axios和统一管理api接口/","link":"","permalink":"http://doraqiao.top/2018/12/29/封装axios和统一管理api接口/","excerpt":"","text":"axios的封装和api接口的统一管理，主要目的就是在帮助我们简化代码和利于后期的更新维护不建议直接复制使用，先理解原理然后再根据实际项目情况写属于自己的axios封装 封装axios新建一个request文件夹，然后在这里面新建一个http.js文件，用来封装我们的axios。（接口用另外一个js文件管理，是因为如果出现接口域名有多个的情况，方便管理。api挂载到vue.prototype上面可以省去引入的步骤）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/*** axios 封装* 请求拦截、相应拦截、错误统一处理* toast是引用mint-ui的，用于提示信息，可自行修改*/import axios from 'axios'import &#123;Toast&#125; from 'mint-ui'import 'mint-ui/lib/toast/style.css'/*提示函数*/const tip = msg=&gt;&#123; Toast(&#123; message:msg, duration: 2500, forbidClick: true, &#125;)&#125;/*** 请求失败后的错误统一处理* 状态码根据实际需求来写内容，这里是简写，方便理解* @param &#123;Number&#125; status 请求失败的状态码*/const errorHandle = (status,msg) =&gt; &#123; switch(status) &#123; case 401: tip(msg) break; case 403: tip(msg) break; case 404: tip(msg) break; case 500: tip(msg) break; default: tip(msg) &#125;&#125;/*创建axios实例 */var instance = axios.create(&#123;timeout:1000*12&#125;)/*设置post请求头*/instance.defaults.headers.post['Content-Type']='application/x-www-form-urlencoded';/*** 请求拦截器*/instance.interceptors.request.use( config =&gt; &#123; return config; &#125;, error =&gt; &#123; return Promise.error(error); &#125;)/***响应拦截器*/instance.interceptors.response.use( //请求成功 res =&gt;&#123; return res.status === 200 ? Promise.resolve(res.data) : Promise.reject(res) &#125;, //请求失败 error =&gt; &#123; const &#123; response &#125; = error; errorHandle(response.status,response.data.msg) return Promise.reject(response) &#125;)export default instance 以上的代码就是我们封装好的axios。在需要使用的时候直接调用这个js文件，方便管理。 api接口模块管理新建一个api文件夹，一个index.js 、 base.js和多个根据模块划分的接口；index.js是一个api的出口，base.js是管理接口域名。 index.js：1234567891011/*** api接口的统一出口*///xxx模块接口import demo from './demo'//导出接口export default &#123; demo,&#125; base.js来管理我们的接口域名，不管有多少个都可以通过这里进行接口的定义。即使修改起来，也是很方便的。12345678910/*** 接口域名的管理*/const base = &#123; urlPre1:'http://xxx.com/xxx', //测试地址 urlPre2:'http://xxx.com/xxx2', //测试地址2&#125;export default base; 接口模块中的js示例： 通过直接引入我们封装好的axios实例，然后定义接口、调用axios实例并返回，可以更灵活的使用axios 请求的配置更灵活，可以针对某个需求进行一个不同的配置。如demo.js：12345678910111213141516171819202122232425262728/*** demo模块接口列表*/import base from './base';//导入接口域名列表import axios from '@/request/http'; //导入http中创建的axios实例,即封装好的axiosimport Qs from 'qs'const demo = &#123; //获取demo信息 getDemo()&#123; return axios(&#123; method:'get', url:base.urlPre1+'/demo' &#125;) &#125;, //新增demo信息 addDemo(params)&#123; params = Qs.stringify(params) return axios(&#123; method:'post', url:base.urlPre1+'/distribution/addUserBank', data:params &#125;) &#125;,&#125;export default demo; 最后在main.js将api统一出口挂载在vue.prototype中（省去引入步骤）12import api from './api'Vue.prototype.$api = api 在需要使用axios的地方，直接调用$api即可12345this.$api.demo.getDemo().then(res=&gt;&#123; console.log(res) &#125;).catch(e =&gt; &#123; console.log(e) &#125;);","categories":[{"name":"vue","slug":"vue","permalink":"http://doraqiao.top/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://doraqiao.top/tags/vue/"},{"name":"axios","slug":"axios","permalink":"http://doraqiao.top/tags/axios/"}]},{"title":"LeetCode题目之础计算法-数学","slug":"LeetCode题目之础计算法-数学","date":"2018-12-19T09:05:52.000Z","updated":"2018-12-21T01:47:56.319Z","comments":true,"path":"2018/12/19/LeetCode题目之础计算法-数学/","link":"","permalink":"http://doraqiao.top/2018/12/19/LeetCode题目之础计算法-数学/","excerpt":"","text":"前言leetCode算法题来到第八步-数学算法题。还是那句话！多思考，一种题型多种解题！ Fizz Buzz写一个程序，输出从 1 到 n 数字的字符串表示。 如果 n 是3的倍数，输出“Fizz”； 如果 n 是5的倍数，输出“Buzz”； 如果 n 同时是3和5的倍数，输出 “FizzBuzz”。 示例：12345678910111213141516171819n = 15,返回:[ \"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\", \"11\", \"Fizz\", \"13\", \"14\", \"FizzBuzz\"] 我的解答：12345678910111213141516var fizzBuzz = function(n) &#123; let arr = [] for(let i =1;i&lt;=n;i++)&#123; if(i%3 == 0 &amp;&amp; i%5 == 0)&#123; console.log(i) arr.push('FizzBuzz') &#125;else if(i%5 == 0)&#123; arr.push('Buzz') &#125;else if(i%3 == 0)&#123; arr.push('Fizz') &#125;else&#123; arr.push(i.toString()) &#125; &#125; return arr&#125;; 计数质数统计所有小于非负整数 n 的质数的数量。示例:123输入: 10输出: 4解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 我的解答12345678910111213141516171819var countPrimes = function(n) &#123; let num = '' for(let i=1;i&lt;n;i++)&#123; if(isPrime(i))&#123; num++ &#125; &#125; return num&#125;;//用于判断是不是质数function isPrime(n)&#123; if(n &lt;= 3) &#123; return n &gt; 1; &#125; if(n % 2 == 0 || n % 3 == 0) &#123; return false; &#125; for(var i = 5; i * i &lt;= n; i += 6)&#123; if(n % i == 0 || n % (i + 2) == 0)&#123; return false; &#125; &#125; return true;&#125; 别人的解答1234567891011121314151617181920var countPrimes = function(n) &#123; if(n &lt;= 2) &#123; return 0 &#125; if(n === 3) &#123; return 1 &#125; var count = 1; var arr = Array(n); for(var i = 3; i &lt; n; i += 2) &#123; if(arr[i] !== undefined) &#123; continue; &#125; count++; for(var j = i; j &lt; n; j += i) &#123; arr[j] = true; &#125; &#125; return count;&#125;; 3的幂给定一个整数，写一个函数来判断它是否是 3 的幂次方。示例 1:12输入: 27输出: true 示例 2:12输入: 0输出: false 示例 3:12输入: 9输出: true 示例 4:12输入: 45输出: false 进阶：你能不使用循环或者递归来完成本题吗？我的解答：12345678910var isPowerOfThree = function(n) &#123; if(n&lt;=0)&#123; return false &#125; let num = String(Math.log10(n)/Math.log10(3)) if(num%1 != 0)&#123; return false &#125; return true&#125;; 别人的解答（代码量更加简洁）123var isPowerOfThree = function(n) &#123; return(n&gt;0 &amp;&amp; Math.log10(n)/Math.log10(3) %1 == 0)&#125;; 罗马数字转整数罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。示例 1:12输入: \"III\"输出: 3 示例 2:12输入: \"IV\"输出: 4 示例 3:12输入: \"IX\"输出: 9 示例 4:123输入: \"LVIII\"输出: 58解释: L = 50, V= 5, III = 3. 示例 5:123输入: \"MCMXCIV\"输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4 我的解答：(代码量极长，最笨拙的方法 请勿参考)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * @param &#123;string&#125; s * @return &#123;number&#125; */var romanToInt = function(s) &#123; let num = 0 for(let i =0,len=s.length;i&lt;len;i++)&#123; if(s[i] == 'I')&#123; if(s[i+1] == 'V')&#123; num+=4 i++ &#125;else if(s[i+1] == 'X')&#123; num+=9 i++ &#125;else&#123; num+=1 &#125; &#125;else if(s[i] == 'X')&#123; if(s[i+1] == 'L')&#123; num+=40 i++ &#125;else if(s[i+1] == 'C')&#123; num+=90 i++ &#125;else&#123; num+=10 &#125; &#125;else if(s[i] == 'C')&#123; if(s[i+1] == 'D')&#123; num+=400 i++ &#125;else if(s[i+1] == 'M')&#123; num+=900 i++ &#125;else&#123; num+=100 &#125; &#125;else if(s[i] == 'V')&#123; num+=5 &#125;else if(s[i] == 'L')&#123; num+=50 &#125;else if(s[i] == 'D')&#123; num+=500 &#125;else if(s[i] == 'M')&#123; num+=1000 &#125; &#125; return num&#125;; 别人的解答：12345678910111213141516171819202122var romanToInt = function(s) &#123; const symbol = &#123; I:1, V:5, X:10, L:50, C:100, D:500, M:1000 &#125;; let sum = 0 let l = s.length for(let i=0;i&lt;l;i++)&#123; if(i&gt;=1 &amp;&amp; (symbol[s[i-1]] &lt; symbol[s[i]]) )&#123; sum += symbol[s[i]] - 2 * symbol[s[i-1]] &#125;else &#123; sum += symbol[s[i]] &#125; &#125; return sum&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://doraqiao.top/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://doraqiao.top/tags/算法/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://doraqiao.top/tags/LeetCode/"}]},{"title":"leetCode题目之初级算法-字符串","slug":"leetCode题目之初级算法-字符串","date":"2018-11-14T03:42:49.000Z","updated":"2018-12-19T09:07:19.041Z","comments":true,"path":"2018/11/14/leetCode题目之初级算法-字符串/","link":"","permalink":"http://doraqiao.top/2018/11/14/leetCode题目之初级算法-字符串/","excerpt":"","text":"前言leetCode算法题来到第二步-字符串算法题。还是那句话！多思考，一种题型多种解题！ 反转字符串编写一个函数，其作用是将输入的字符串反转过来。示例 1:12输入: &quot;hello&quot;输出: &quot;olleh&quot; 示例 2:12输入: &quot;A man, a plan, a canal: Panama&quot;输出: &quot;amanaP :lanac a ,nalp a ,nam A&quot; 我的解答：1234var reverseString = function(s) &#123; s = s.split(&quot;&quot;).reverse().join(&quot;&quot;) return s&#125;; 颠倒整数给定一个 32 位有符号整数，将整数中的数字进行反转。示例 1:12输入: 123输出: 321 示例 2:12输入: -123输出: -321 示例 3:12输入: 120输出: 21 注意:假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。根据这个假设，如果反转后的整数溢出，则返回 0。 我的解答：123456789101112var reverse = function(x) &#123; let y=0 while(x)&#123; y = y*10 + x%10 x = parseInt(x/10) &#125; return y &lt; Math.pow(-2,31) || y &gt; Math.pow(2,31) ? 0 : y; /* if(y &lt;= Math.pow(-2,31) || y &gt;= Math.pow(2,31) - 1 )&#123; return 0 &#125; return y */&#125;; 字符串中的第一个唯一字符给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。案例:12345s = &quot;leetcode&quot;返回 0.s = &quot;loveleetcode&quot;,返回 2. 注意事项：您可以假定该字符串只包含小写字母。 我的解答：123456789101112var firstUniqChar = function(s) &#123; let temp = &#123;&#125;; for(let i of s)&#123; temp[i] = temp[i] +1 || 1; &#125; for(let j in temp)&#123; if(temp[j] == 1)&#123; return s.indexOf(j) &#125; &#125; return -1&#125;; 别人的解答：12345678var firstUniqChar = function(s) &#123; for(let i=0;i&lt;s.length;i++)&#123; if(s.indexOf(s.charAt(i)) == s.lastIndexOf(s.charAt(i)))&#123; return i &#125; &#125; return -1&#125;; 有效的字母异位词给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的一个字母异位词。示例 1:12输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true 示例 2:12输入: s = &quot;rat&quot;, t = &quot;car&quot;输出: false 说明:你可以假设字符串只包含小写字母。进阶:如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ 我的解答：1234567891011121314151617var isAnagram = function(s, t) &#123; if(s.length != t.length)&#123; return false &#125; let temp = &#123;&#125; for(let i of s)&#123; temp[i] = temp[i] + 1 || 1 &#125; for(let j of t)&#123; if(j in temp &amp;&amp; temp[j] &gt;0)&#123; temp[j] -= 1 &#125;else&#123; return false &#125; &#125; return true&#125;; 别人的解答：1234567891011121314151617181920212223242526272829303132//解答一var isAnagram = function (s, t) &#123; var chars = Array(26).fill(0); for (var i = 0; i &lt; s.length; i++) &#123; chars[s.charCodeAt(i) - 97]++; &#125; for (var i = 0; i &lt; t.length; i++) &#123; chars[t.charCodeAt(i) - 97]--; &#125; for (var i = 0; i &lt; chars.length; i++) &#123; if (chars[i] !== 0) &#123; return false; &#125; &#125; return true;&#125;;//解答二var isAnagram = function(s, t) &#123; let len = s.length; if(len != t.length) return false; let n = 0; for(let i=0;i&lt;len;i++)&#123; n += Math.pow(2,(97 - s[i].charCodeAt()) + 1); n -= Math.pow(2,(97 - t[i].charCodeAt()) + 1); &#125; if(n) return false; return true;&#125;; 验证回文字符串给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。说明：本题中，我们将空字符串定义为有效的回文串。示例 1:12输入: &quot;A man, a plan, a canal: Panama&quot;输出: true 示例 2:12输入: &quot;race a car&quot;输出: false 我的解答：123456789101112var isPalindrome = function(s) &#123; //s = s.toLowerCase().replace(/\\s+/g, &quot;&quot;).replace(/[\\ |\\~|\\`|\\!|\\@|\\#|\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\-|\\_|\\+|\\=|\\||\\\\|\\[|\\]|\\&#123;|\\&#125;|\\;|\\:|\\&quot;|\\&apos;|\\,|\\&lt;|\\.|\\&gt;|\\/|\\?]/g,&quot;&quot;); //[^指定字符串] 指的是除指定字符串以外的其他字符串 s = s.toLowerCase().replace(/[^a-zA-Z0-9]+/g,&quot;&quot;) console.log(s); for(let i =0,j=s.length-1;i&lt;j;i++,j--)&#123; if(s[i] != s[j])&#123; return false &#125; &#125; return true&#125;; 字符串转整数 (atoi)实现 atoi，将字符串转为整数。该函数首先根据需要丢弃任意多的空格字符，直到找到第一个非空格字符为止。如果第一个非空字符是正号或负号，选取该符号，并将其与后面尽可能多的连续的数字组合起来，这部分字符即为整数的值。如果第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。字符串可以在形成整数的字符后面包括多余的字符，这些字符可以被忽略，它们对于函数没有影响。当字符串中的第一个非空字符序列不是个有效的整数；或字符串为空；或字符串仅包含空白字符时，则不进行转换。若函数不能执行有效的转换，返回 0。说明：假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。如果数值超过可表示的范围，则返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。示例 1:12输入: &quot;42&quot;输出: 42 示例 2:1234输入: &quot; -42&quot;输出: -42解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3:123输入: &quot;4193 with words&quot;输出: 4193解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。 示例 4:1234输入: &quot;words and 987&quot;输出: 0解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。 因此无法执行有效的转换。 示例 5:1234输入: &quot;-91283472332&quot;输出: -2147483648解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 我的解答：12345678910111213141516171819var myAtoi = function(str) &#123; let num = &apos;&apos;; if(!str)&#123; return 0 &#125; if(parseInt(str))&#123; if(parseInt(str) &lt;= Math.pow(-2,31))&#123; num = Math.pow(-2,31) &#125;else if(parseInt(str) &gt;= Math.pow(2,31) -1)&#123; num = Math.pow(2,31) -1 &#125; if(num == &apos;&apos;)&#123; num = parseInt(str) &#125; &#125;else&#123; return 0 &#125; return num&#125;; 实现strStr()给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。示例 1:12输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;输出: 2 示例 2:12输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;输出: -1 说明:当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。 我的解答：123var strStr = function(haystack, needle) &#123; return haystack.indexOf(needle)&#125;; 报数报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：123451. 12. 113. 214. 12115. 111221 1 被读作 “one 1” (“一个一”) , 即 11。11 被读作 “two 1s” (“两个一”）, 即 21。21 被读作 “one 2”, “one 1” （”一个二” , “一个一”) , 即 1211。给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。注意：整数顺序将表示为一个字符串。示例 1:12输入: 1输出: &quot;1&quot; 示例 2:12输入: 4输出: &quot;1211&quot; 我的解答：1234567891011121314151617var countAndSay = function(n) &#123; let num = &apos;1&apos; for(let i=1;i&lt;n;i++)&#123; let repeatCount = 1 let str = &apos;&apos; for(let j=0;j&lt;num.length;j++)&#123; if(num[j] == num[j+1])&#123; repeatCount++ &#125;else&#123; str += repeatCount + num[j] repeatCount = 1 &#125; &#125; num = str &#125; return num&#125;; 最长公共前缀编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。示例 1:12输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot; 示例 2:123输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。 说明:所有输入只包含小写字母 a-z 。我的解答：1234567891011121314151617181920212223242526272829var longestCommonPrefix = function(strs) &#123; let str = &apos;&apos;; let jugde = 1; if(strs.length == 0)&#123; return str &#125; for(let i=0;i&lt;strs[0].length;i++)&#123; let charA = strs[0].charAt(i); for(let j=0;j&lt;strs.length;j++)&#123; if(i&gt;=strs[j].length)&#123; jugde = 0; break; &#125; if(strs[j].charAt(i) != charA)&#123; jugde = 0; break; &#125; if(j == strs.length-1)&#123; str += charA &#125; &#125; if(jugde == 0)&#123; break; &#125; &#125; return str&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://doraqiao.top/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://doraqiao.top/tags/算法/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://doraqiao.top/tags/LeetCode/"}]},{"title":"leetCode题目之初级算法-数组","slug":"leetCode题目之初级算法","date":"2018-11-12T03:46:50.000Z","updated":"2018-11-14T03:16:07.402Z","comments":true,"path":"2018/11/12/leetCode题目之初级算法/","link":"","permalink":"http://doraqiao.top/2018/11/12/leetCode题目之初级算法/","excerpt":"","text":"前言作为一个小白技术渣渣，适当的锻炼下算法的能力也是非常有必要的！刷题过程中会发现一个题目多种解题方式，算是给自己提供不同的思路吧！LeetCode官方称题目刷三遍当然是最好的啦，毕竟每次做题都是不一样的收获。当然不要死记硬背答案，因为答案不唯一！ 从数组删除重复项给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。示例 1:123给定数组 nums = [1,1,2],函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。你不需要考虑数组中超出新长度后面的元素。 示例 2:123给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 我的解答：1234567891011var removeDuplicates = function(nums) &#123; let k =0; for(let i=0;i&lt;nums.length;i++)&#123; if(nums[i] != nums[k])&#123; k++; nums[k] = nums[i]; &#125; &#125; nums.splice(k+1) return nums.length&#125;; 买卖股票的最佳时机 II给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。示例 1:1234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2:12345输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3:123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 我的解答：123456789var maxProfit = function(prices) &#123; let nums = 0; for(let i=0;i&lt;prices.length;i++)&#123; if(prices[i] &lt; prices[i+1])&#123; nums+= prices[i+1] - prices[i]; &#125; &#125; return nums&#125;; 旋转数组给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例 1:123456输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4] 示例 2:12345输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释:向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100] 说明:尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。要求使用空间复杂度为 O(1) 的原地算法。 我的解答：1234567891011121314151617181920//解答1var rotate = function(nums, k) &#123; for(let i=0;i&lt;k;i++)&#123; nums.unshift(nums[nums.length-1]) nums.pop(); &#125; return nums;&#125;;//解答2var rotate = function(nums, k) &#123; for(let i=0;i&lt;k;i++)&#123; nums.splice(0,0,nums[nums.length-1]); nums.pop(); &#125; return nums;&#125;;//解答3var rotate = function(nums, k) &#123; nums.unshift(...nums.splice(nums.length-k))&#125;; 存在重复给定一个整数数组，判断是否存在重复元素。如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。示例 1:12输入: [1,2,3,1]输出: true 示例 2:12输入: [1,2,3,4]输出: false 示例 3:12输入: [1,1,1,3,3,4,3,2,4,2]输出: true 我的解答：12345678910var containsDuplicate = function(nums) &#123; nums.sort(); if(nums.length&lt;=1)&#123;return false&#125; for(let i=0;i&lt;nums.length;i++)&#123; if(nums[i] == nums[i+1])&#123; return true; &#125; &#125; return false;&#125;; 别人的解题：(根据es6语法糖 set)12const set = new Set(nums)return set.size !== nums.length 只出现一次的数字给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1:12输入: [2,2,1]输出: 1 示例 2:12输入: [4,1,2,1,2]输出: 4 我的解答：1234567var singleNumber = function(nums) &#123; let num = 0 for(let i=0;i&lt;nums.length;i++)&#123; num ^= nums[i] &#125; return num&#125;; 两个数组的交集 II给定两个数组，编写一个函数来计算它们的交集。示例 1:12输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2,2] 示例 2:12输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [4,9] 说明：输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。我们可以不考虑输出结果的顺序。进阶: 如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果 nums1 的大小比 nums2 小很多，哪种方法更优？ 如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 我的解答：123456789101112131415161718192021222324252627//普通版var intersect = function(nums1, nums2) &#123; let temp = &#123;&#125; let newArr = []; for(let i=0;i&lt;nums1.length;i++)&#123; if(nums1[i] in temp)&#123; temp[nums1[i]] += 1; &#125;else&#123; temp[nums1[i]] = 1; &#125; &#125; for(let j in nums2)&#123; if(temp[nums2[j]] &gt;0)&#123; newArr.push(nums2[j]) temp[nums2[j]] -= 1 &#125; /*if(nums2[j] in temp)&#123; newArr.push(nums2[j]) if(temp[nums2[j]] &gt;1)&#123; temp[nums2[j]] -= 1 &#125;else&#123; delete temp[nums2[j]] &#125; &#125;*/ &#125; return newArr&#125;; 别人的解答：（思路一致，但是更加简洁）1234567891011121314let intersect = function(nums1, nums2) &#123; let res = []; let map = &#123;&#125;; for (let e of nums1) &#123; map[e] = map[e] + 1 || 1; &#125; for (let e of nums2) &#123; if (map[e]) &#123; res.push(e); map[e]--; &#125; &#125; return res;&#125;; 加一给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1:123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 示例 2:123输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 我的解答：123456789101112131415var plusOne = function(digits) &#123; for(let i=digits.length-1;i&gt;=0;i--)&#123; if(digits[i] !=9)&#123; digits[i] += 1; break; return digits; &#125;else&#123; digits[i] = 0 if(i == 0)&#123; digits.unshift(1) &#125; &#125; &#125; return digits;&#125;; 移动零给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。示例:12输入: [0,1,0,3,12]输出: [1,3,12,0,0] 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 我的解答：1234567891011121314151617181920212223242526272829303132//解答一（不推荐）var moveZeroes = function(nums) &#123; let temp = &apos;&apos;; if(nums.length &lt;= 1) &#123; return nums; &#125; for(let i=0;i&lt;nums.length;i++)&#123; for(let j=i+1;j&lt;nums.length;j++)&#123; if(nums[i] == 0)&#123; var tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; &#125; &#125; &#125; return nums&#125;;//解答二var moveZeroes = function(nums) &#123; let count = 0 for(let i=0;i&lt;nums.length;i++)&#123; if(nums[i] == 0)&#123; nums.splice(i,1) i-- count++ &#125; &#125; for(let j=0;j&lt;count;j++)&#123; nums.push(0) &#125; return nums&#125;; 两数之和给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。示例:nums 123因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 我的解答：123456789101112var twoSum = function(nums, target) &#123; let numsArr = []; for(var i=0;i&lt;nums.length;i++)&#123; for(var j=i+1;j&lt;nums.length;j++)&#123; if(nums[i] + nums[j] == target)&#123; numsArr.push(i); numsArr.push(j); return numsArr; &#125; &#125; &#125;&#125;; 别人的解答：1234567891011var twoSum = function(nums, target) &#123; var result = &#123;&#125;; for (var i=0, len=nums.length; i &lt; len; i++) &#123; var expected = target - nums[i]; if (result[expected] !== undefined) &#123; return [result[expected], i]; &#125; result[nums[i]] = i; &#125; return null;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://doraqiao.top/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://doraqiao.top/tags/算法/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://doraqiao.top/tags/LeetCode/"}]},{"title":"使用vue开发项目时所遇到的问题","slug":"使用vue开发项目时所遇到的问题","date":"2018-10-29T03:44:39.000Z","updated":"2018-10-29T08:34:04.037Z","comments":true,"path":"2018/10/29/使用vue开发项目时所遇到的问题/","link":"","permalink":"http://doraqiao.top/2018/10/29/使用vue开发项目时所遇到的问题/","excerpt":"","text":"vue打包问题 打包路径问题 由于打包之后，是被压缩成status文件夹和index.html，所以在路径方面有一定的差异；所以打包之前需要在config&gt;index.js文件下修改build下的（红标部分）;加个小点表示相对路径，不加表示绝对路径。 打包后图片的路径问题： 在开发的时候，在img和background的图片引入中，将路径使用绝对路径来引用，即/static/……；这样在打包之后，图片路径会直接指向根路径，导致图片路径错误；所以在开发的过程中，图片的路径最好使用相对路径，在打包的过程中会自动转换，在打包之后就不会出现图片路径问题； 在background中，使用以上方法引图片时，build之后如果出现路径名的不对，可以使用如下方式：正确配置后既可以正确引用 在build&gt;util.js下找到： 添加红色框中的内容即可 报错：The data property “show” is already declared as a prop. Use prop default value instead.原因：是因为 组件里传进去的参数又在data 里面定义过，然后报错；即在props里有，又在data中定义了，造成冲突；所以将data中定义的删除即可； 引入axios 很多人引用axios之前都会引用vue-axios，其实不需要引入vue-axios。vue官方文档也更加推荐使用axios来使用ajax；安装vue-axios是为了让axios可以全局使用，下面这个方法也可以让axios全局使用 使用 Vue.prototype.$axios = axios 来全局引用即可，调用时直接this.$axios即可 axios.defaults.baseURL = ‘’ 设置接口地址的前缀 控制v-for里面显示某个数据：在使用v-for的标签里 加上v-if的判断语句 目前所遇到的问题暂时是这些啦，后续如果有更多的问题会上来更新！本人小白渣渣，如有错漏请提出，谢谢~","categories":[{"name":"vue","slug":"vue","permalink":"http://doraqiao.top/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://doraqiao.top/tags/vue/"}]},{"title":"学习用hexo搭建博客","slug":"学习用hexo搭建博客","date":"2018-10-10T09:46:17.000Z","updated":"2018-10-12T10:05:26.117Z","comments":true,"path":"2018/10/10/学习用hexo搭建博客/","link":"","permalink":"http://doraqiao.top/2018/10/10/学习用hexo搭建博客/","excerpt":"","text":"前言整个博客的搭建方法，均是参考此篇博文进行搭建，其中前面的讲解非常详细，由于我的电脑已经有git和node.js的环境，所以我是直接从安装hexo开始，到绑定域名结束。博主写的挺好的，适合小白从零搭建我在此总结下自己搭建的时候一些操作与问题记录 各种文档 张小花的博客（参考此博文搭建博客的） hexo hexo的官方文档，里面也有些命令行的讲解，适当的查看文档也是非常有帮助 hueman主题hexo里面的一个主题，张小花博主用的是这个主题，我刚开始搭建，所以也参照博主用这个；里面也有对应的说明，详情看其wiki 关于markdown语法的文档，请搜索引擎寻找~ 安装hexo1$npm i -g hexo （对于linux小白:请输入上面的命令时不要输入$,从$后面的内容开始输入，同下）嫌npm慢者可以用cnpm 安装地址 查看hexo的版本：1$hexo -v 初始化hexo命令：1$hexo init 初始化之后可以看到：blog文件夹下面有这些东西 解释下图片中对应的文件作用： node_modules：是依赖包 public：存放的是生成的页面 scaffolds：命令生成文章等的模板 source：用命令创建的各种文章 themes：主题 _config.yml：整个博客的配置 db.json：source解析所得到的 package.json：项目所需模块项目的配置信息 生成SSH并添加到github进入github -&gt; new repository -&gt; 填写各种信息（其中doraqiao是我github的名称，请更改为自己的github名称才生效；description是描述，可以填写一些描述，也可以后期补上） 上面配置完毕后，在gitbash上配置github账户信息：（name和email请换成你自己的github name 和邮箱）12$git config --global user.name &quot;YourName&quot;$git config --global user.email &quot;YourEmail&quot; 上述完成后，生成SSH：(输入github邮箱账号)1$ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 然后找到id_rsa.pub文件的内容，获取的内容就是我们需要的ssh12$cd ~/.ssh$cat id_rsa.pub 将文件内容放到github上 点击 new ssh key title可以填blog（方便以后辨识），也可以自己取key就把文件的内容放进来 添加后，验证是否添加成功：1$ssh -T git@github.com 如图所示：表示添加成功 部署项目在根目录下的 _config.yml 文件进行配置：（冒号之后都是有一个半角空格的）1234deploy: type: git repo: https://github.com/YourName/YourName.github.io.git branch: master 配置之后，进入blog目录，执行：123$hexo clean$hexo generate$hexo server 执行完毕之后，在浏览器输入：http://localhost:4000就可以看到你的博客啦！ 上传到github让你写好的文章部署到github上并让别人浏览，所以需要安装：1$npm install hexo-deployer-git --save 然后再执行此命令：123$hexo clean$hexo generate$hexo deploy ps:deploy的过程中需要输入你的username和password最后，在浏览器中输入http://yourgithubname.github.io 就可以看到个人博客 绑定个人域名 先购买域名啦！我是在万网购买的域名啦，附上地址 添加CNAME：在根目录下source文件夹新建一个名为CNAME的文件（没有后缀），里面添加购买的域名，只能添加一个（如我添加的是doraqiao.top） 在dns解析里面，添加一条记录，其中ip为你的github地址（在cmd中ping获取） 最后再次执行123$hexo clean$hexo g$hexo d 然后用域名打开，就可以看到博客啦！","categories":[{"name":"搭建博客","slug":"搭建博客","permalink":"http://doraqiao.top/categories/搭建博客/"}],"tags":[{"name":"hexo搭建博客","slug":"hexo搭建博客","permalink":"http://doraqiao.top/tags/hexo搭建博客/"}]}]}